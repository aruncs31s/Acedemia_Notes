---
id: callout
aliases: []
tags:
  - files
  - templates
  - templater
dg-publish: true
title: callout
---

# Bilinear transform

Bilinear transform is one of those clever DSP tricks where math pulls a disguise-change on systems: it takes an **analog filter** (defined in the continuous-time $s$-plane) and warps it into a **digital filter** (in the discrete-time $z$-plane) without letting the filter misbehave (no aliasing, no weirdness).

## **What is Bilinear Transformation? (DSP TL;DR version)**

It is a mathematical mapping that converts an analog transfer function $H(s)$ into a digital transfer function $H(z)$ through:

$$s = \frac{2}{T}\,\frac{1 - z^{-1}}{1 + z^{-1}}$$

This mapping compresses the infinite analog $s$-plane onto the inside of the unit circle of the digital $z$-plane, which keeps **stability → stability**.

## **Why is it used? (Practical sense)**

Engineers use it because:
1. It avoids aliasing — unlike impulse invariance.
2. It preserves filter order.
3. Stable analog → stable digital.
4. You can design using well-known analog methods (Butterworth, Chebyshev) and convert them easily.

* * *

## **Steps to design a filter using Bilinear Transformation**


### **1. Start with digital filter specs**

Example: passband edge $\omega_p$, stopband edge $\omega_s$, sampling time $T$.

### **2. Pre-warp the digital frequencies**

Because bilinear transform bends the frequency axis, we “unbend” it first:

$$\Omega = \frac{2}{T} \tan\left(\frac{\omega}{2}\right)$$

This gives analog passband frequency $\Omega_p$ and stopband frequency $\Omega_s$.

### **3. Design analog prototype filter**

Use analog formulas (Butterworth, Chebyshev, etc.)
* Compute filter **order**
* Compute analog transfer function $H(s)$

For Butterworth:

$$|H(j\Omega)|^2 = \frac{1}{1 + (\Omega/\Omega_c)^{2N}}$$
### **4. Apply bilinear transformation**
Replace:
$$s \longleftarrow \frac{2}{T}\frac{1 - z^{-1}}{1 + z^{-1}}$$
in the analog $H(s)$.

This produces a rational function in $z^{-1}$:

$$H(z) = \frac{b_0 + b_1 z^{-1} + \dots}{1 + a_1 z^{-1} + \dots}$$

Now you have the digital IIR filter.

### **5. Implement using difference equation**

Convert coefficients into:

$$y[n] = -a_1 y[n-1] - a_2 y[n-2] + b_0 x[n] + b_1 x[n-1] + \ldots$$

Drop it into C / Python / MATLAB / GNU Radio.

* * *

## **A mental model**

Imagine the bilinear transform as a wormhole:  
Everything in analog time flows through it and reappears in discrete time with its shape still intact—just frequency-warped. Butterworth stays Butterworth-ish, which is why DSP people love it.

* * *

If you want, I can take any of your exam questions (from the PDF) and solve them one by one using bilinear transformation with actual numbers.

* * *



# Question 15 (Module-3)

<iframe width="560" height="315" src="https://www.youtube.com/embed/M2mqomtRyVo?si=7c7wY8-DWUqzRAc8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

![[Pasted image 20251114220529.png]]

**15 a)** Design a Butterworth filter using bilinear transformation.

**Given (interpreted from the paper):** 

==Passband==: $0.9 \le |H(e^{j\omega})| \le 1,\; 0\le\omega\le\omega_p$.  
==Stopband==: $|H(e^{j\omega})|\le 0.2,\; \omega_s = 3\pi/4 \le \omega \le \pi$.  
==Sampling period== $T=1$ s.  
==Passband Freq==:$\omega_{p} = \frac{\pi}{2}$
==Stopband== : $\omega_{s}\frac{3\pi}{3}$

![[Screenshot 2025-11-14 at 10.08.40 PM.png]]

![[Screenshot 2025-11-14 at 10.29.02 PM.png]]

### Step 1 — Convert magnitudes to dB & compute $\epsilon$
Pass-band magnitude lower bound $0.9$ → passband ripple (dB)

$$A_p = -20\log_{10}(0.9) \approx 0.91515\ \text{dB}.$$

Stop-band magnitude limit $0.2$ → stopband attenuation

$$A_s = -20\log_{10}(0.2) \approx 13.9794\ \text{dB}.$$

For a Butterworth prototype:

$$\varepsilon^2 = 10^{0.1 A_p} - 1.$$

Compute numerically:

$$\varepsilon^2 \approx 10^{0.091515}-1 \approx 0.2346,\quad \varepsilon\approx 0.4844.$$

### Step 2 — Prewarp digital edge frequencies (bilinear warping)

Prewarp formula:

$$\Omega = \frac{2}{T}\tan\!\frac{\omega}{2}$$

With $T=1$, and the choices $\omega_p=\pi/2$, $\omega_s=3\pi/4$,

$$\Omega_p = 2\tan\!\frac{\pi/4}{ } = 2\cdot 1 = 2.0$$ $$\Omega_s = 2\tan\!\frac{3\pi/8}{ } = 2\cdot 2.41421356 \approx 4.82842712.$$

So $\displaystyle\frac{\Omega_s}{\Omega_p}\approx 2.41421356.$

### Step 3 — Compute minimum Butterworth order $N$

Use the standard formula

$$N \ge \frac{\log_{10}\!\big(\dfrac{10^{0.1A_s}-1}{10^{0.1A_p}-1}\big)}{2\log_{10}(\Omega_s/\Omega_p)}.$$

Plugging numbers (rounded steps shown earlier):

$$10^{0.1A_s}-1 \approx 25 - 1 = 24,\qquad 10^{0.1A_p}-1 \approx 0.2346.$$ $$\frac{24}{0.2346}\approx 102.322\quad\Rightarrow\quad \log_{10}(\cdots)\approx 2.010.$$ $$2\log_{10}(2.4142)\approx 0.7656.$$ $$N \ge \frac{2.010}{0.7656}\approx 2.626\;\Rightarrow\; N = \lceil 2.626\rceil = 3.$$

**Answer:** Minimum order $N=3$.

### Step 4 — Compute analog cutoff $\Omega_c$

For Butterworth the passband condition gives

$$\left(\frac{\Omega_p}{\Omega_c}\right)^{2N} = \varepsilon^2 \quad\Rightarrow\quad \Omega_c=\frac{\Omega_p}{\varepsilon^{1/N}}.$$

With $N=3$, $\varepsilon \approx 0.4844$:

$$\varepsilon^{1/3}\approx 0.7856 \quad\Rightarrow\quad \Omega_c \approx \frac{2}{0.7856}\approx 2.547.$$

### Step 5 — Analog prototype $H_a(s)$

A normalized Butterworth $N=3$ has poles at

$$s_k = \Omega_c \exp\!\big(j\pi\frac{2k+N-1}{2N}\big),\quad k=0,\dots,N-1,$$

take the left-half plane ones. The analog lowpass transfer (normalized for unity DC gain) is

$$H_a(s)=\frac{\Omega_c^3}{(s-p_1)(s-p_2)(s-p_3)},$$

with the three poles $p_i$ computed above (use the angles formula to get the numerical complex poles). (I can compute the explicit pole values and show the factorized form if you want.)

### Step 6 — Bilinear transform to get $H(z)$

Substitute

$$s \leftarrow \frac{2}{T}\frac{1-z^{-1}}{1+z^{-1}}$$

(with $T=1$) into $H_a(s)$, simplify, multiply numerator and denominator by $(1+z^{-1})^N$ to get a causal rational $H(z)$ in powers of $z^{-1}$. Then extract coefficients $\{b_k\}$, $\{a_k\}$ and write the difference equation

$$y[n] = -a_1 y[n-1]-a_2 y[n-2]-a_3 y[n-3] + b_0 x[n] + b_1 x[n-1]+b_2 x[n-2]+b_3 x[n-3].$$

* * *

### Summary / final numeric results you can use

* Prewarped $\Omega_p = 2.0$, $\Omega_s \approx 4.8284$.
    
* Filter order $N=3$.
    
* Analog cutoff $\Omega_c \approx 2.547$.
    
* Analog prototype poles: compute from formula above → substitute into $H_a(s)$.
    
* Final digital $H(z)$ is obtained by the direct substitution $s\to\frac{2(1-z^{-1})}{1+z^{-1}}$ and collecting coefficients.
    

If you want, I’ll compute the explicit numeric pole values and the final $H(z)$ coefficients (and give the difference-equation) next — but that requires some algebraic expansion / arithmetic; say the word and I’ll grind out the coefficients now.

* * *

> [!example]- Go Code
> ```go
> // butterworth_bilinear.go
> // Compute Butterworth analog prototype and map to digital via bilinear transform (T=1).
> // Solves the exam-style 15(a) design with given specs.
> // Usage: go run butterworth_bilinear.go
> 
> package main
> 
> import (
> 	"fmt"
> 	"math"
> 	"math/cmplx"
> )
> 
> // Complex polynomial utilities (coefficients in ascending power order: c[0] + c[1] x + ...)
> 
> func polyMul(a, b []complex128) []complex128 {
> 	res := make([]complex128, len(a)+len(b)-1)
> 	for i := range res {
> 		res[i] = 0 + 0i
> 	}
> 	for i := 0; i < len(a); i++ {
> 		for j := 0; j < len(b); j++ {
> 			res[i+j] += a[i] * b[j]
> 		}
> 	}
> 	return res
> }
> 
> func polyAdd(a, b []complex128) []complex128 {
> 	n := int(math.Max(float64(len(a)), float64(len(b))))
> 	res := make([]complex128, n)
> 	for i := 0; i < n; i++ {
> 		var av, bv complex128
> 		if i < len(a) {
> 			av = a[i]
> 		}
> 		if i < len(b) {
> 			bv = b[i]
> 		}
> 		res[i] = av + bv
> 	}
> 	return res
> }
> 
> func polyScale(a []complex128, s complex128) []complex128 {
> 	res := make([]complex128, len(a))
> 	for i := range a {
> 		res[i] = a[i] * s
> 	}
> 	return res
> }
> 
> func polyPow(base []complex128, exp int) []complex128 {
> 	// Binary exponentiation
> 	res := []complex128{1 + 0i}
> 	if exp == 0 {
> 		return res
> 	}
> 	b := make([]complex128, len(base))
> 	copy(b, base)
> 	for exp > 0 {
> 		if exp&1 == 1 {
> 			res = polyMul(res, b)
> 		}
> 		b = polyMul(b, b)
> 		exp >>= 1
> 	}
> 	return res
> }
> 
> func polyFromRoots(roots []complex128) []complex128 {
> 	// returns polynomial coefficients for Π (x - r_k), ascending order
> 	// start with 1
> 	coef := []complex128{1 + 0i}
> 	for _, r := range roots {
> 		// multiply coef by (x - r) => multiply by [ -r, 1 ]
> 		coef = polyMul(coef, []complex128{-r, 1 + 0i})
> 	}
> 	// coef currently ascending order
> 	return coef
> }
> 
> func complexSliceToRealApprox(a []complex128) []float64 {
> 	res := make([]float64, len(a))
> 	for i := range a {
> 		res[i] = real(a[i])
> 		// drop tiny imaginary part (should be near zero)
> 		if math.Abs(imag(a[i])) > 1e-8 {
> 			// keep real part, but warn (we won't fail)
> 			// In practice values are real within numerical precision.
> 		}
> 	}
> 	return res
> }
> 
> func main() {
> 	// Given specs (as per your clarified problem)
> 	T := 1.0
> 	wp := math.Pi / 2.0      // passband edge (rad)
> 	ws := 3.0 * math.Pi / 4.0 // stopband edge (rad)
> 	Gp := 0.9                // passband magnitude lower bound
> 	Gs := 0.2                // stopband magnitude upper bound
> 
> 	// 1) ripple (dB) and epsilon
> 	Ap := -20.0 * math.Log10(Gp)
> 	As := -20.0 * math.Log10(Gs)
> 	eps2 := math.Pow(10.0, 0.1*Ap) - 1.0
> 	eps := math.Sqrt(eps2)
> 
> 	fmt.Printf("Specs:\n  wp=%.6f rad  ws=%.6f rad  T=%.3f\n", wp, ws, T)
> 	fmt.Printf("  Gp=%.3f  Gs=%.3f  => Ap=%.6f dB  As=%.6f dB\n", Gp, Gs, Ap, As)
> 	fmt.Printf("  eps^2=%.6e  eps=%.6e\n\n", eps2, eps)
> 
> 	// 2) prewarp (bilinear prewarp formula Omega = 2/T * tan(w/2))
> 	OmegaP := 2.0 / T * math.Tan(wp/2.0)
> 	OmegaS := 2.0 / T * math.Tan(ws/2.0)
> 	fmt.Printf("Prewarped analog frequencies (T=%.3f):\n  Omega_p=%.9f  Omega_s=%.9f\n\n", T, OmegaP, OmegaS)
> 
> 	// 3) find minimum N
> 	num := math.Log10((math.Pow(10.0, 0.1*As) - 1.0) / (math.Pow(10.0, 0.1*Ap) - 1.0))
> 	den := 2.0 * math.Log10(OmegaS/OmegaP)
> 	Nf := num / den
> 	N := int(math.Ceil(Nf))
> 	fmt.Printf("Filter order estimate: N >= %.6f => choose N = %d\n\n", Nf, N)
> 
> 	// 4) compute Omega_c (cutoff)
> 	// For Butterworth: OmegaC = OmegaP / eps^(1/N)
> 	OmegaC := OmegaP / math.Pow(eps, 1.0/float64(N))
> 	fmt.Printf("Analog cutoff Omega_c = %.9f\n\n", OmegaC)
> 
> 	// 5) compute analog poles (scaled)
> 	roots := make([]complex128, N)
> 	for k := 0; k < N; k++ {
> 		angle := math.Pi * float64(2*k+N-1) / (2.0 * float64(N))
> 		roots[k] = complex(OmegaC*math.Cos(angle), OmegaC*math.Sin(angle))
> 	}
> 	fmt.Printf("Analog (s-plane) poles (scaled by Omega_c):\n")
> 	for i, r := range roots {
> 		fmt.Printf(" p%d = %.9f %+ .9fi\n", i+1, real(r), imag(r))
> 	}
> 	fmt.Println()
> 
> 	// 6) analog denominator polynomial D(s) = Π (s - p_k) => coefficients d0*s^N + d1*s^(N-1) + ... + dN
> 	// Using polyFromRoots (ascending), but that gives coeffs for Π (x - r), as [c0, c1, ...]
> 	// polyFromRoots returns coefficients in ascending order (constant term first)
> 	DcoeffAsc := polyFromRoots(roots) // length N+1
> 	// We want coefficients for s^{N}, s^{N-1}, ... in array d[0..N] where d0 = 1 (monic)
> 	// polyFromRoots returns c[0] + c[1] s + ... + c[N] s^N
> 	// let's make d_k = coefficient of s^{N-k} = c[N-k]
> 	Dcoeff := make([]complex128, N+1)
> 	for k := 0; k <= N; k++ {
> 		// d_k corresponds to s^{N-k}
> 		Dcoeff[k] = DcoeffAsc[N-k]
> 	}
> 	fmt.Printf("Analog denominator D(s) coefficients (d0*s^N + d1*s^(N-1)+...+ dN):\n")
> 	for k := 0; k <= N; k++ {
> 		fmt.Printf(" d%d = %+ .12f%+ .12fi\n", k, real(Dcoeff[k]), imag(Dcoeff[k]))
> 	}
> 	fmt.Println()
> 
> 	// For a normalized Butterworth with unity DC gain, numerator = Omega_c^N (a constant)
> 	numConst := math.Pow(OmegaC, float64(N))
> 	numConstC := complex(numConst, 0)
> 
> 	// 7) Bilinear substitution: s = 2*(1 - w)/(1 + w) where w = z^{-1}
> 	// Multiply numerator & denominator by (1 + w)^N to clear denominators.
> 	// Result:
> 	//  Numerator_poly_w = numConst * (1 + w)^N
> 	//  Denominator_poly_w = sum_{k=0..N} d_k * 2^{N-k} * (1 - w)^{N-k} * (1 + w)^{k}
> 
> 	// base polys: (1 - w) => ascending coeffs [1, -1], (1 + w) => [1, 1]
> 	oneMinusW := []complex128{1 + 0i, -1 + 0i}
> 	onePlusW := []complex128{1 + 0i, 1 + 0i}
> 
> 	// numerator poly in w:
> 	numPolyW := polyScale(polyPow(onePlusW, N), numConstC) // complex poly
> 
> 	// denominator constructing:
> 	// Dcoeff[k] corresponds to s^{N-k}; for each k add Dcoeff[k] * 2^{N-k} * (1-w)^{N-k} * (1+w)^{k}
> 	denPolyW := make([]complex128, 1) // start zero
> 	denPolyW[0] = 0 + 0i
> 	for k := 0; k <= N; k++ {
> 		power1 := N - k
> 		power2 := k
> 		term1 := polyPow(oneMinusW, power1)
> 		term2 := polyPow(onePlusW, power2)
> 		tmp := polyMul(term1, term2)
> 		scale := complex(math.Pow(2.0, float64(power1)), 0) * Dcoeff[k]
> 		tmp = polyScale(tmp, scale)
> 		denPolyW = polyAdd(denPolyW, tmp)
> 	}
> 
> 	// Now numPolyW and denPolyW are polynomials in w (w = z^{-1}), ascending order.
> 	// Make sure both have length N+1
> 	L := N + 1
> 	if len(numPolyW) < L {
> 		// pad
> 		for len(numPolyW) < L {
> 			numPolyW = append(numPolyW, 0+0i)
> 		}
> 	}
> 	if len(denPolyW) < L {
> 		for len(denPolyW) < L {
> 			denPolyW = append(denPolyW, 0+0i)
> 		}
> 	}
> 
> 	// Normalize so leading denominator coefficient (highest power of w? careful: ascending)
> 	// For ascending order, highest power is index L-1. But classical filter a0 corresponds to highest power? We have
> 	// H(z) = (b0 + b1 z^-1 + ... + bN z^-N) / (a0 + a1 z^-1 + ... + aN z^-N)
> 	// Here our polynomials are in w = z^-1 ascending order, so a0 = denPolyW[0] (constant) ??? Let's check:
> 	// We formed D(s(w)) * (1+w)^N which yields polynomial in w with powers 0..N. The constant term corresponds to w^0.
> 	// In usual filter form we want leading coefficient a0 = coefficient at w^0 (constant). So normalize by denPolyW[0].
> 	// Confirm by evaluating at w=0 (z=inf?), but standard derivation yields a0 = denPolyW[0].
> 	// We'll normalize so a0 == 1.
> 
> 	a0 := denPolyW[0]
> 	if cmplx.Abs(a0) == 0 {
> 		fmt.Println("Unexpected zero leading denominator coefficient")
> 		return
> 	}
> 
> 	// Normalize
> 	bCoeffs := make([]complex128, L)
> 	aCoeffs := make([]complex128, L)
> 	for i := 0; i < L; i++ {
> 		bCoeffs[i] = numPolyW[i] / a0
> 		aCoeffs[i] = denPolyW[i] / a0
> 	}
> 
> 	// Print polynomial coefficients (real approx)
> 	fmt.Printf("Digital IIR coefficients (z^-1 form, b0 + b1 z^-1 + ... + bN z^-N)\n")
> 	fmt.Printf(" b (numerator):\n")
> 	for i := 0; i < L; i++ {
> 		fmt.Printf("  b%d = %+ .9f (imag %+ .9f)\n", i, real(bCoeffs[i]), imag(bCoeffs[i]))
> 	}
> 	fmt.Printf("\n a (denominator):\n")
> 	for i := 0; i < L; i++ {
> 		fmt.Printf("  a%d = %+ .9f (imag %+ .9f)\n", i, real(aCoeffs[i]), imag(aCoeffs[i]))
> 	}
> 	fmt.Println()
> 
> 	// Print as difference equation y[n] = -a1 y[n-1] - ... + b0 x[n] + b1 x[n-1]...
> 	fmt.Println("Difference equation (approx, using real parts):")
> 	// convert to real arrays
> 	bReal := complexSliceToRealApprox(bCoeffs)
> 	aReal := complexSliceToRealApprox(aCoeffs)
> 	fmt.Printf(" y[n] = ")
> 	// denominators (skip a0)
> 	for i := 1; i < L; i++ {
> 		if i > 1 {
> 			fmt.Printf(" - %.9fy[n-%d]", aReal[i], i)
> 		} else {
> 			fmt.Printf("- %.9fy[n-%d]", aReal[i], i)
> 		}
> 	}
> 	// add numerator terms
> 	if L > 0 {
> 		fmt.Printf(" + %.9fx[n]", bReal[0])
> 	}
> 	for i := 1; i < L; i++ {
> 		fmt.Printf(" + %.9fx[n-%d]", bReal[i], i)
> 	}
> 	fmt.Println("\n")
> 
> 	// Final sanity prints (DC gain)
> 	sumB := 0.0
> 	sumA := 0.0
> 	for i := 0; i < L; i++ {
> 		sumB += bReal[i]
> 		sumA += aReal[i]
> 	}
> 	fmt.Printf("Check DC gain approx: sum(b)/sum(a) = %.12f\n", sumB/sumA)
> }
> ```


> [!abstract]- Python Code
> 
> ```python
> # Compute values for Butterworth design as per specs
> import numpy as np
> T=1.0
> omega_p = np.pi/2
> omega_s = 3*np.pi/4
> Ap = -20*np.log10(0.9)  # passband ripple dB
> As = -20*np.log10(0.2)  # stopband attenuation dB
> eps_sq = 10**(0.1*Ap)-1
> eps = np.sqrt(eps_sq)
> # prewarp
> Omega_p = 2/T * np.tan(omega_p/2)
> Omega_s = 2/T * np.tan(omega_s/2)
> # compute N
> num = np.log10(10**(0.1*As)-1) - np.log10(eps_sq)
> den = 2*np.log10(Omega_s/Omega_p)
> N = int(np.ceil(num/den))
> # compute Omega_c for Butterworth: Omega_c = Omega_p / (eps**(1/N))
> Omega_c = Omega_p / (eps**(1.0/N))
> Ap, As, eps, Omega_p, Omega_s, N, Omega_c
> 
> print(Omega_c)
> ```



# Question 15 (part b)

**15 b)** Derive magnitude and phase for an FIR filter with symmetric impulse response and even length $N$.

**Short derivation / result (exam style):**

Let the FIR length be $N$ and index range $n=0,\dots,N-1$. Define $M=N-1$. Symmetry:

$$h[n]=h[M-n],\quad n=0,\dots,M.$$

Then the DTFT is

$$H(e^{j\omega})=\sum_{n=0}^{M} h[n] e^{-j\omega n}  
= e^{-j\omega M/2}\underbrace{\sum_{n=0}^{M} h[n] e^{-j\omega(n-M/2)}}_{A(\omega)}.$$

Because $h[n]$ is symmetric, the bracket $A(\omega)$ is **real and even** (a sum of cosines). Therefore

* **Magnitude**
    
    $$|H(e^{j\omega})| = |A(\omega)|$$
    
    since $|e^{-j\omega M/2}|=1$.
    
* **Phase**
    
    $$\angle H(e^{j\omega}) = -\omega\frac{M}{2} + \begin{cases} 0 & A(\omega)>0\\ \pi & A(\omega)<0\end{cases}$$

So symmetric impulse response ⇒ linear phase with slope $-M/2$ (group delay $M/2$). In words: the amplitude is given by a real even cosine-sum and the phase is linear (plus possible $\pi$ flips where the real amplitude changes sign).

(If you want the explicit cosine expansion for even $N$ I can write the exact closed-form; I kept it compact exam-style.)

* * *

# Question 16 (Module-3)

**16 a)**  
Desired frequency response (from paper):

$$H_d(\omega)=\begin{cases}  
e^{-j\omega 5}, & |\omega|\le 3\pi/4,\\[4pt]  
0, & \text{otherwise},  
\end{cases}$$

Design an FIR (use Hamming window, $N=7$). **Find the FIR frequency response / impulse response.**

**Solution (standard window method):**

Ideal (infinite) impulse response for a bandlimited delayed lowpass:

$$h_d[n] = \frac{1}{2\pi}\int_{-3\pi/4}^{3\pi/4} e^{-j\omega 5} e^{j\omega n}\,d\omega  
= \frac{1}{\pi}\frac{\sin\!\big((3\pi/4)(n-5)\big)}{(n-5)},\quad n\neq 5,$$

and

$$h_d[5] = \frac{3\pi/4}{\pi} = \tfrac{3}{4}=0.75.$$

We truncate to length $N=7$, i.e. indices $n=0,1,\dots,6$ (a causal, centered delay built into the desired response).

Compute the (numerical) ideal samples $h_d[n]$ for $n=0\dots6$ (rounded):

* $$n=0:\; n-5=-5 \Rightarrow h_d[0]\approx -0.04503$$
    
* $$n=1:\; -4 \Rightarrow h_d[1]=0$$
    
* $$n=2:\; -3 \Rightarrow h_d[2]\approx +0.07505$$
    
* $$n=3:\; -2 \Rightarrow h_d[3]\approx -0.159155$$
    
* $$n=4:\; -1 \Rightarrow h_d[4]\approx +0.22508$$
    
* $$n=5:\; 0 \Rightarrow h_d[5]=+0.75$$
    
* $$n=6:\; +1 \Rightarrow h_d[6]\approx +0.22508$$
    

Hamming window for $N=7$ is

$$w[n]=0.54-0.46\cos\!\frac{2\pi n}{N-1}=0.54-0.46\cos\frac{2\pi n}{6},$$

values:

$$w=[0.08,\;0.31,\;0.77,\;1.00,\;0.77,\;0.31,\;0.08].$$

Windowed impulse response $h[n]=h_d[n]\cdot w[n]$:

Numeric results (rounded 6 significant digits):

* $$h[0]\approx -0.003602$$
    
* $$h[1]=0$$
    
* $$h[2]\approx 0.057789$$
    
* $$h[3]\approx -0.159155$$
    
* $$h[4]\approx 0.173307$$
    
* $$h[5]\approx 0.232500$$
    
* $$h[6]\approx 0.018006$$
    

So the FIR coefficients (length-7) are approximately:

$$h \approx [-0.003602,\;0,\;0.057789,\;-0.159155,\;0.173307,\;0.232500,\;0.018006].$$

The frequency response is

$$H(e^{j\omega})=\sum_{n=0}^{6} h[n] e^{-j\omega n}$$

which you can evaluate numerically or plot with MATLAB/Python. These $h[n]$ are ready to implement.

* * *

**16 b)** (paper text garbled)  
The PDF shows the analog $H(s)$ expression badly mangled — I cannot reliably read the transfer function text (it looks like `H(s)=+ sz+rF2s+1` in the PDF). I can’t safely convert it to a digital Butterworth via impulse invariance without the correct analytic form.

If you re-upload or paste the exact $H(s)$ (clear equation), I’ll complete 16(b) immediately: do the impulse-invariance mapping, compute poles/ residues, and give the final second-order digital filter.

* * *

# What I’ve finished & next steps

* Completed Q15 (design procedure + numeric order $N=3$, $\Omega_c$). I can compute the explicit analog poles and expand to get exact $H(z)$ and difference-equation coefficients on demand.
    
* Completed Q15(b) theoretical derivation (linear phase result).
    
* Completed Q16(a) with numeric windowed FIR coefficients $h[n]$ for the Hamming window, $N=7$.
    
* **I could not complete Q16(b)** because the printed analog $H(s)$ in your scan is unreadable. Please paste or re-upload the correct expression for $H(s)$ (or type it), and I’ll finish 16(b) straight away.
    

* * *

If you want, I’ll:

* compute the explicit analog pole values and the final $H(z)$ coefficients for Q15 (digital IIR coefficients ready to implement), **or**
    
* generate MATLAB/Python code to verify magnitude/phase plots and to produce the plots for both Q15 and Q16, or
    
* finish Q16(b) after you provide the exact $H(s)$.
    

Tell me which of those you want and I’ll continue (I already have everything needed except the Q16(b) formula).

* * *

**You:**

2. Prewarp digital edge frequencies (bilinear, (T=1)) $$ \Omega_p=\tan!\left(\frac{\omega_p}{2}\right)=\tan!\left(\frac{\pi/2}{2}\right)=\tan!\left(\frac{\pi}{4}\right)=1, $$ $$ \Omega_s=\tan!\left(\frac{\omega_s}{2}\right)=\tan!\left(\frac{3\pi}{8}\right)=1+\sqrt{2}\approx 2.41421356. $$ is this correct? 

* * *

**ChatGPT:**

Yes — the structure is correct **except for one tiny thing**:  
You forgot the factor **2** that normally appears in the bilinear prewarping formula when $T = 1$.

Let’s straighten it out cleanly.

* * *

# The bilinear prewarp formula

For bilinear transform with sampling period $T$:

$$\Omega = \frac{2}{T}\tan\left(\frac{\omega}{2}\right)$$

If $T = 1$:

$$\Omega = 2 \tan\left(\frac{\omega}{2}\right)$$

That “2” comes from the substitution

$$s = \frac{2}{T}\frac{1 - z^{-1}}{1 + z^{-1}}$$

* * *

# Now plug the values correctly

### Passband edge

Given  
$\omega_p = \pi/2$:

$$\Omega_p = 2 \tan\left(\frac{\pi/2}{2}\right)  
= 2 \tan\left(\frac{\pi}{4}\right)  
= 2(1)  
= 2$$

### Stopband edge

Given  
$\omega_s = 3\pi / 4$:

$$\Omega_s = 2 \tan\left(\frac{3\pi/4}{2}\right)  
= 2 \tan\left(\frac{3\pi}{8}\right)  
= 2 (1+\sqrt{2})$$

Since $\tan(3\pi/8) = 1 + \sqrt{2} \approx 2.41421356$:

$$\Omega_s = 2 \times 2.41421356 = 4.82842712$$

* * *

# Final verdict

Your formula **matches the right structure**, but your result is missing the factor of 2.

Correct values:

* $$\Omega_p = 2$$
    
* $$\Omega_s \approx 4.82842712$$
    

Your values:

* $1$ and $2.4142…$
    

are exactly half of the correct ones.

* * *

If you want, I can re-solve the entire bilinear Butterworth design using these corrected prewarped frequencies, which gives clean numbers and helps matching exam expectations.




# Similar Problem
Given $T=1$, $\omega_p = \pi/2$, $\omega_s = 3\pi/4$.
* Passband magnitude lower bound $=0.707$ (i.e. $-3\ \text{dB}$ point)
    
* Stopband magnitude upper bound $=0.2$
    

* * *

## 1) Pass/stop ripple (dB) and $\varepsilon$

$$A_p = -20\log_{10}(0.70710678)\approx -20(-0.150515)=3.010299\ \text{dB}.$$ $$A_s = -20\log_{10}(0.2)\approx 13.979400\ \text{dB}.$$ $$\varepsilon^2 = 10^{0.1A_p}-1 = 10^{0.3010299}-1 = 2 - 1 = 1 \quad\Rightarrow\quad \varepsilon = 1.$$

(Exactly: $\varepsilon=1$ because $A_p=3.0103\ \mathrm{dB}$ is the −3 dB point.)

* * *

## 2) Prewarp digital edges (bilinear, $T=1$)

Formula: $\displaystyle \Omega = \frac{2}{T}\tan\!\frac{\omega}{2}$.

$$\Omega_p = 2\tan\!\frac{\pi/4}=2\cdot 1=2.0000000000$$ $$\Omega_s = 2\tan\!\frac{3\pi}{8}=2(1+\sqrt{2}) \approx 4.8284271247$$

* * *

## 3) Minimum Butterworth order $N$

Use

$$N \ge \frac{\log_{10}\!\big(\dfrac{10^{0.1A_s}-1}{10^{0.1A_p}-1}\big)}{2\log_{10}(\Omega_s/\Omega_p)}.$$

Compute numerator and denominator:

* $$10^{0.1A_s}-1 \approx 10^{1.39794}-1 \approx 25 - 1 = 24.$$
    
* $$10^{0.1A_p}-1 = 10^{0.30103}-1 = 2-1 = 1.$$
    
* Ratio $=24$. $\log_{10}(24)\approx 1.3802112417.$
    

$\Omega_s/\Omega_p = 4.8284271247/2 = 2.41421356235.$  
$\log_{10}(2.41421356235)\approx 0.3827929885.$  
Denominator $2\log_{10}(\Omega_s/\Omega_p) \approx 0.765585977.$

Thus

$$N \ge 1.3802112417/0.765585977 \approx 1.803\ \Rightarrow\ N=\lceil1.803\rceil = 2.$$

**Minimum order: $$N=2$$.**

* * *

## 4) Analog cutoff $\Omega_c$

For Butterworth:

$$\Omega_c = \frac{\Omega_p}{\varepsilon^{1/N}} = \frac{2}{1^{1/2}} = 2.0000000000.$$

So $\Omega_c = 2$.

* * *

## 5) Analog prototype (normalized) — $N=2$

Normalized 2nd-order Butterworth denominator (for $\Omega_c=1$) is:

$$s^2 + \sqrt{2}\,s + 1.$$

Scale to $\Omega_c=2$ by replacing $s\to s/\Omega_c$ or multiply coefficients appropriately → final analog transfer:

Numerator (constant) $= \Omega_c^2 = 4.$  
Denominator:

$$s^2 + (\sqrt{2}\cdot 2)\, s + 2^2 = s^2 + 2\sqrt{2}\,s + 4.$$

Numeric: $2\sqrt{2}\approx 2.82842712474619.$

So

$$H_a(s)=\frac{4}{s^2 + 2.82842712474619\,s + 4}.$$

* * *

## 6) Bilinear transform $s \leftarrow \dfrac{2(1 - z^{-1})}{1 + z^{-1}}$

Let $w=z^{-1}$. Substitute and multiply numerator & denominator by $(1+w)^2$ to clear fractions.

After algebra (step-by-step expansion) we get:

Numerator (in $w$): $4(1+w)^2 = 4 + 8w + 4w^2.$  
Denominator (in $w$): $13.65685424949238 + 0\cdot w + 2.3431457505076194\, w^2.$

Normalize denominator constant term to 1 by dividing numerator and denominator by $13.65685424949238$.

Thus the digital filter coefficients (for powers $z^{-0}, z^{-1}, z^{-2}$) are:

### Numerator $b$:

$$\begin{aligned}  
b_0 &= \dfrac{4}{13.65685424949238} \approx 0.2928932188134525,\\  
b_1 &= \dfrac{8}{13.65685424949238} \approx 0.5857864376269050,\\  
b_2 &= \dfrac{4}{13.65685424949238} \approx 0.2928932188134525.  
\end{aligned}$$

### Denominator $a$ (normalized $a_0=1$):

$$\begin{aligned}  
a_0 &= 1.0000000000000000,\\  
a_1 &= 0.0000000000000000,\\  
a_2 &= \dfrac{2.3431457505076194}{13.65685424949238} \approx 0.17157287525380988.  
\end{aligned}$$

Sanity check (DC gain):

$$\frac{b_0+b_1+b_2}{a_0+a_1+a_2}  
=\frac{0.2928932188+0.5857864376+0.2928932188}{1+0+0.1715728753}=1.0$$

so DC gain = 1 (good).

* * *

## 7) Difference equation (implementation-ready)

$$y[n] = -a_1\,y[n-1] - a_2\,y[n-2] + b_0\,x[n] + b_1\,x[n-1] + b_2\,x[n-2].$$

Substitute numeric values:

$$y[n] = -0.0000000000\,y[n-1] -0.1715728753\,y[n-2] \\  
\qquad\qquad +\,0.2928932188\,x[n] +0.5857864376\,x[n-1] +0.2928932188\,x[n-2].$$

(Effectively $a_1=0$.)

* * *

## Summary (compact)

* $A_p \approx 3.0103\ \mathrm{dB},\; A_s\approx13.9794\ \mathrm{dB}$.
    
* $\varepsilon = 1$.
    
* $\Omega_p = 2,\; \Omega_s \approx 4.82842712$.
    
* Minimum order $N=2$.
    
* $\Omega_c = 2$.
    
* Analog prototype: $H_a(s)=\dfrac{4}{s^2 + 2.8284271247 s + 4}$.
    
* Digital coefficients (z⁻¹ form):
    
    * $$b = [0.2928932188,\;0.5857864376,\;0.2928932188]$$
        
    * $$a = [1.0,\;0.0,\;0.1715728753]$$
        

You can copy those $b,a$ values straight into MATLAB/Python/Go for filtering or for plotting the frequency response to verify the passband and stopband specs.

I’ve produced the exact numeric coefficients; if you want, I’ll (a) paste the small Go program that prints these numbers (or runs the full algebra like before) or (b) produce a quick Python snippet to plot the magnitude response so you can verify the -3 dB and stopband attenuation visually.